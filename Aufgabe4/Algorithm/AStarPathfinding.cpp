#include <algorithm>

#include "AStarPathfinding.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  The base of this code is generated by ChatGPT.                                    //
//                                  It is modified to fit my own purposes.                                            //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


namespace Algorithm
{

    std::vector<Node*> FindPath(int startCol, int startRow, int endCol, int endRow, Game::Map& map)
    {
        std::vector<Node*> openNodes;
        std::vector<Node*> visitedNodes;

        Node* startNode = new Node(startCol, startRow, 0, CalculateHeuristic(startCol, startRow, endCol, endRow), nullptr);
        openNodes.push_back(startNode);

        while (!openNodes.empty())
        {
            // Lambda Function which is needed as condition to find the lowest FCost with std::min_element
            auto compareNodes = [](const Node* a, const Node* b)->bool{ return a->GetFCost() < b->GetFCost(); };
            // minCostNode stores an iterator, pointing at the element with the lowest FCost
            auto minCostNode = std::min_element(openNodes.begin(), openNodes.end(), compareNodes);

            // you have to dereference the iterator in order to use its value
            Node* currentNode = *minCostNode;
            openNodes.erase(minCostNode);
            visitedNodes.push_back(currentNode);

            // if the algorithm has reached the end, it backtracks the path and safes it in a separate vector
            if (currentNode->col == endCol && currentNode->row == endRow)
            {
                std::vector<Node*> path;
                ReconstructPath(currentNode, path);
                CleanupNodes(openNodes);
                CleanupNodes(visitedNodes);
                return path;
            }

            std::vector<Node*> neighbors = GetNeighbors(*currentNode, endCol, endRow, map);

            for (Node* neighbor : neighbors)
            {
                if (std::find(visitedNodes.begin(), visitedNodes.end(), neighbor) != visitedNodes.end())
                    continue;

                int tentativeGCost = currentNode->gCost + 1;

                auto it = std::find(openNodes.begin(), openNodes.end(), neighbor);
                if (it == openNodes.end() || tentativeGCost < (*it)->gCost)
                {
                    neighbor->gCost = tentativeGCost;
                    neighbor->hCost = CalculateHeuristic(neighbor->col, neighbor->row, endCol, endRow);
                    neighbor->parent = currentNode;

                    if (it == openNodes.end())
                        openNodes.push_back(neighbor);
                }
            }
        }

        CleanupNodes(openNodes);
        CleanupNodes(visitedNodes);

        return std::vector<Node*>();
    }

    int CalculateHeuristic(int col, int row, int endCol, int endRow)
    {
        return std::abs(endCol - col) + std::abs(endRow - row);
    }

    std::vector<Node*> GetNeighbors(const Node& node, int endCol, int endRow, Game::Map& map)
    {
        std::vector<Node*> neighbors;

        int moves[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };

        for (int i = 0; i < 4; ++i)
        {
            int newCol = node.col + moves[i][0];
            int newRow = node.row + moves[i][1];

            if (newCol >= 0 && newCol < Game::Map::mapWidth - 1 && newRow >= 0 && newRow < Game::Map::mapHeight - 1
                && (map.map[newCol][newRow] == Game::TileState::PASSABLE || map.map[newCol][newRow] == Game::TileState::ITEM))
            {
                Node* neighbor = new Node(newCol, newRow, 0, CalculateHeuristic(newCol, newRow, endCol, endRow), const_cast<Node*>(&node));
                neighbors.push_back(neighbor);
            }
        }

        return neighbors;
    }

    void ReconstructPath(Node* node, std::vector<Node*>& path)
    {
        while (node != nullptr)
        {
            path.push_back(node);
            node = node->parent;
        }

        std::reverse(path.begin(), path.end());
    }

    void CleanupNodes(const std::vector<Node*>& nodes)
    {
        for (Node* node : nodes)
        {
            delete node;
        }
    }

}